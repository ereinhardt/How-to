
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>How to?</title>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.1.5/hls.js"
      integrity="sha512-YR4vWgTmC0QwRfYKWTy1eTMvBYpmAsSGP76is/15Uxqfa3N/qYRZKFE8pf66GsfSrFksaJkNmbTS2BcdLamZoA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <style>
    body {
      margin: 0;
      height: 100vh;
      width: 100vw;
      background-color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: hidden;
    }

    .main {
      position: absolute;
      margin: auto;
      z-index: 1000;
      max-width: 177.78vh;
      max-height: 100vh;
      width: 100vw;
      height: calc(100vw / 1.7778);
    }
    
    .Video {
      width: 100%;
      position: absolute;
      height: 100%;
      top: 0;
      z-index: -9999;
    }

    .Search {
      height: 30px;
      padding-left: 10px;
      width: 100%;
      display: flex;
      justify-content: start;
      align-items: center;
    }

    .Search input {
      width: 100px;
      height: 14px;
    }
    
    .Search span {
      cursor: pointer;
    }

    .Stamps {
      height: calc(50% - 31px);
      overflow-y: auto;
      width: 100%;
      margin-left: 8px;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
    }

    .Stamps::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    #active {
      color: red;
    }

    #notification {
      margin-left: 10px;
      color: red;
      cursor: auto;
    }
  </style>

  <body>
    <div class="main">
      <div class="Search">
        <span> How to&nbsp;</span>
        <input type="text" name="" value="" maxlength="25" />
        <span id="search_span"><button id="search_button">?</button></span>
        <span id="notification"></span>
      </div>
      <div class="Stamps"></div>
      <div class="Video">
        <video
          src=""
          controls
          controlslist="noplaybackrate nodownload nofullscreen"
          autoplay
          style="display: none; width: 100%; height: auto"
        ></video>
      </div>
    </div>
    <script>
      const socket = io();
      const elements = {
        input: null,
        video: null,
        searchButton: null,
        notification: null,
        stamps: null
      };

      let hls_context;
      let is_searching = false;
      let networkErrorCount = 0;
      let socketReconnectAttempts = 0;
      let timeupdateHandler = null;
      let seekHandler = null;

      const MAX_NETWORK_ERRORS = 1;
      const MAX_SOCKET_RECONNECT_ATTEMPTS = 5;

      // Initialize DOM element references
      document.addEventListener('DOMContentLoaded', () => {
        elements.input = document.querySelector('.Search input');
        elements.video = document.querySelector('video');
        elements.searchButton = document.getElementById('search_button');
        elements.notification = document.getElementById('notification');
        elements.stamps = document.querySelector('.Stamps');
      });

      // UI state management
      function setSearchingState(searching) {
        is_searching = searching;
        elements.input.readOnly = searching;
        elements.searchButton.disabled = searching;
        document.body.style.cursor = searching ? 'wait' : 'auto';
      }

      function setNotification(message) {
        elements.notification.innerText = `(${message})`;
        setTimeout(() => elements.notification.innerHTML = "", 3000);
      }

      // Socket event handlers
      socket.on("connect", () => {
        console.log("Socket connected with ID:", socket.id);
        socketReconnectAttempts = 0;
      });

      socket.on("disconnect", (reason) => {
        console.log("Socket disconnected:", reason);
        if ((reason === "io server disconnect" || reason === "transport close") && hls_context) {
          console.log("Server connection lost during streaming.");
          setNotification("Connection to server lost.");
          setTimeout(resetToInitialState, 2000);
        } else if (reason === "io server disconnect") {
          console.log("Server disconnected, reconnecting...");
          socket.connect();
        }
      });

      socket.on("connect_error", (error) => {
        console.error("Socket connection error:", error);
        if (++socketReconnectAttempts >= MAX_SOCKET_RECONNECT_ATTEMPTS) {
          console.log("Max socket reconnection attempts reached.");
          setNotification("Unable to connect to server.");
          if (hls_context || is_searching) {
            setTimeout(() => {
              resetToInitialState();
              socketReconnectAttempts = 0;
            }, 2000);
          }
        }
      });

      // Event listeners
      document.getElementById("search_span").addEventListener("click", () => {
        if (!is_searching) start_search();
      });

      document.querySelector('.Search input').addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !is_searching) start_search();
      });

      // Handle search errors uniformly
      function handleSearchError(errorType, message) {
        console.log(`${errorType} received:`, message);
        setNotification("Search failed. Please try again.");
        setSearchingState(false);
        resetToInitialState();
      }

      // Start new search and handle server communication
      async function start_search() {
        console.log("Starting new search...");
        await destroy_hls_context();
        deleteAllTimestamps();

        elements.video.style.display = "none";
        document.body.style.backgroundColor = "white";

        const search_value = `How to ${elements.input.value}`;
        setSearchingState(true);

        console.log("Disconnecting socket for clean state...");
        socket.disconnect();

        // Remove old listeners
        ["START_STREAM", "GEMINI_API_ERROR", "MAX_RETRIES_ERROR", "SEARCH_ERROR", "STREAM_ENDED"]
          .forEach(event => socket.removeAllListeners(event));

        // Set up listeners BEFORE reconnecting
        socket.on("START_STREAM", (source_url, user) => {
          console.log("Starting HLS stream:", source_url);
          console.log("User data received:", user);
          setSearchingState(false);
          
          try {
            start_hls(source_url);
            generatingTimestamps(user.questions);
          } catch (error) {
            console.error("Error starting stream:", error);
            setNotification("Failed to start stream.");
          }
        });

        socket.on("GEMINI_API_ERROR", (error) => handleSearchError("Gemini API Error", error.message));
        socket.on("MAX_RETRIES_ERROR", (error) => handleSearchError("Max Retries Error", error.message));
        socket.on("SEARCH_ERROR", (error) => handleSearchError("Search Error", error.message));
        
        socket.on("STREAM_ENDED", () => {
          console.log("Stream ended by server.");
          setSearchingState(false);
          resetToInitialState();
        });

        // Reconnect and send the search request
        console.log("Reconnecting socket...");
        if (socket.disconnected) socket.connect();

        // Wait for connection
        await new Promise(resolve => {
          socket.connected ? resolve() : socket.once("connect", resolve);
        });

        const display_search = search_value.endsWith('?') ? search_value : search_value + '?';
        console.log("Emitting NEW_SEARCH:", display_search);
        socket.emit("NEW_SEARCH", { search: search_value, is_first: true });
      }

      // Clean up and destroy HLS streaming context
      async function destroy_hls_context() {
        if (!hls_context) return;
        
        try {
          hls_context.stopLoad();
          hls_context.detachMedia();

          if (hls_context.coreComponents) {
            hls_context.coreComponents.forEach(comp => {
              if (comp?.abort) comp.abort();
            });
          }

          hls_context.destroy();
          await new Promise(r => setTimeout(r, 100));
        } catch (e) {
          console.error("Error stopping HLS stream:", e);
        }
        
        hls_context = null;
      }

      // Initialize HLS video streaming
      function start_hls(source_url) {
        elements.video.style.display = "block";
        networkErrorCount = 0;
        
        if (!Hls.isSupported()) {
          return setNotification("HLS is not supported.");
        }

        hls_context = new Hls({
          levelLoadingTimeOut: 10000,
          manifestLoadingTimeOut: 10000,
          levelLoadingMaxRetryTimeout: 64000,
          levelLoadingMaxRetry: 3,
          manifestLoadingMaxRetry: 3,
          manifestLoadingMaxRetryTimeout: 64000,
          autoStartLoad: true,
          debug: false,
          liveDurationInfinity: false,
          maxBufferLength: 20,
          liveSyncDurationCount: 5,
          backBufferLength: 20,
          adjustTs: true,
          forceKeyFrameOnDiscontinuity: true,
          maxSeekHole: 1,
        });

        hls_context.loadSource(source_url);
        hls_context.attachMedia(elements.video);
        document.body.style.backgroundColor = "black";

        hls_context.on(Hls.Events.ERROR, function (event, data) {
          if (!data.fatal) return;
          
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              if (++networkErrorCount >= MAX_NETWORK_ERRORS) {
                console.log("Max network errors reached.");
                setNotification("Connection to server lost.");
                resetToInitialState();
                networkErrorCount = 0;
                return;
              }
              
              console.log(`Network error ${networkErrorCount}/${MAX_NETWORK_ERRORS}, attempting recovery...`);
              if (hls_context) hls_context.startLoad(-1);
              
              setTimeout(() => {
                if (hls_context?.media?.error) {
                  console.log("Network recovery failed.");
                  setNotification("Connection failed. Please try again.");
                  resetToInitialState();
                  networkErrorCount = 0;
                }
              }, 5000);
              break;
              
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.log("Fatal media error, attempting recovery...");
              hls_context.recoverMediaError();
              break;
              
            default:
              console.log("Fatal error type:", data.type);
              setNotification("Stream error occurred.");
              resetToInitialState();
              networkErrorCount = 0;
          }
        });

        hls_context.on(Hls.Events.FRAG_LOAD_ERROR, (event, data) => {
          console.error("Fragment load error:", data);
        });

        elements.video.addEventListener("ended", () => {
          console.log("Stream ended (#EXT-X-ENDLIST).");
          resetToInitialState();
        });

        hls_context.on(Hls.Events.LEVEL_UPDATED, (event, data) => {
          if (data.details?.endOfStream) {
            console.log("Stream end detected via level update.");
            resetToInitialState();
          }
        });
      }

      // Remove all timestamp elements from the DOM
      function deleteAllTimestamps() {
        elements.stamps.innerHTML = '';
      }

      // Reset application to initial state
      function resetToInitialState() {
        console.log("Resetting to initial state...");
        destroy_hls_context();
        networkErrorCount = 0;
        socketReconnectAttempts = 0;
        
        elements.video.style.display = "none";
        elements.video.src = "";
        elements.input.value = "";
        elements.input.readOnly = false;
        document.body.style.backgroundColor = "white";
        deleteAllTimestamps();

        if (timeupdateHandler) {
          elements.video.removeEventListener("timeupdate", timeupdateHandler);
          timeupdateHandler = null;
        }

        if (seekHandler) {
          elements.video.removeEventListener("seeked", seekHandler);
          seekHandler = null;
        }

        is_searching = false;
        elements.searchButton.disabled = false;
        document.body.style.cursor = "auto";
        
        console.log("Reset complete.");
      }

      // Generate timestamps and handle video time events
      function generatingTimestamps(questions) {
        let currentIndex = 1;

        if (timeupdateHandler) {
          elements.video.removeEventListener("timeupdate", timeupdateHandler);
        }
        if (seekHandler) {
          elements.video.removeEventListener("seeked", seekHandler);
        }

        timeupdateHandler = () => {
          const time = elements.video.currentTime;
          if (currentIndex < questions.length && time > questions[currentIndex].startTimeInSec) {
            generateTimeStamp(questions[currentIndex]);
            updateActiveTimestamp(time, questions);
            currentIndex++;
          }
        };
        elements.video.addEventListener("timeupdate", timeupdateHandler);

        seekHandler = () => updateActiveTimestamp(elements.video.currentTime, questions);
        elements.video.addEventListener("seeked", seekHandler);
      }

      // Update which timestamp is currently active based on video time
      function updateActiveTimestamp(currentTime, questions) {
        let activeQuestionIndex = 0;

        for (let i = questions.length - 1; i >= 0; i--) {
          if (currentTime >= questions[i].startTimeInSec) {
            activeQuestionIndex = i;
            break;
          }
        }

        const allLinks = document.querySelectorAll(".Stamps a");
        allLinks.forEach(link => link.id = "");

        if (activeQuestionIndex === 0 && currentTime <= questions[0].startTimeInSec) {
          allLinks[0]?.scrollIntoView({ behavior: "smooth", block: "end" });
          return;
        }

        const activeQuestion = questions[activeQuestionIndex];
        if (activeQuestion) {
          const displayTitle = formatQuestionTitle(activeQuestion.question);
          allLinks.forEach(link => {
            if (link.innerText === displayTitle) {
              link.id = "active";
              link.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          });
        }
      }

      // Format question title consistently
      function formatQuestionTitle(title) {
        const withQuestion = title.endsWith('?') ? title : title + '?';
        return withQuestion.charAt(0).toUpperCase() + withQuestion.slice(1).toLowerCase();
      }

      // Generate single timestamp entry
      function generateTimeStamp(question) {
        const wrapper = document.createElement("div");
        wrapper.className = "timestamp-item";
        
        const link = document.createElement("a");
        link.href = "#";
        link.innerText = formatQuestionTitle(question.question);
        link.onclick = (e) => {
          e.preventDefault();
          elements.video.currentTime = question.startTimeInSec;
          setActiveLink(link);
        };
        
        wrapper.appendChild(link);
        elements.stamps.appendChild(wrapper);
      }

      // Set which timestamp link is visually active
      function setActiveLink(linkElem) {
        document.querySelectorAll(".Stamps a").forEach(a => a.id = "");
        linkElem.id = "active";
      }

      // Scroll to currently active timestamp
      function scrollToActiveTimestamp() {
        document.querySelector(".Stamps a#active")?.scrollIntoView({ 
          behavior: "smooth", 
          block: "center" 
        });
      }

      window.addEventListener("resize", () => {
        setTimeout(scrollToActiveTimestamp, 100);
      });
    </script>
  </body>
</html>